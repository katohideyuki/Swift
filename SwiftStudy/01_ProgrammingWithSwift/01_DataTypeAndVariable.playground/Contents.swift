import UIKit

/**
 ■ 変数の定義
 -----------------------------------------------------------------
 識別子の後に型名を定義する。1行に複数の定義を記述しないのならセミコロン「;」は必
 要ない。特に理由がなければ初期値を設定して型名は明記しないのが推奨。なお、型も初
 期値も指定しない場合はエラーになる。トップレベル（関数やクラスなどの定義の外側）
 のグローバルな変数名をカンマ「, 」
 -----------------------------------------------------------------

 */
変数定義の概要: do {
    var age : Int = 18      // 型宣言と初期値を記述
    var age2 = 18           // 初期値から型を推論(ageはInt型)
    age = 20                // varで宣言した変数は値を変更できる

    var width = 10.5, height = 9.25, kind = "Rect"      // Double, Double, String
    var pack: Int = 0, x, y: Int, ram, rem: Double      // 初期値がない場合は型の指定が必須
    x   = 1
    y   = 2
    ram = 3.3
    rem = 4.4
    // 変数を一度も使わないと警告が出るから、出力する
    print("age = \(age), age2 = \(age2), width = \(width), height = \(height), kind = \(kind)")
    print("pack = \(pack), x = \(x), y = \(y), ram = \(ram), rem = \(rem)")
}

/**
 -----------------------------------------------------------------
 ■ 定数の定義
 先頭に`let`を定義する。通常は初期値を省略せずに記述する。定数の値を後から変更す
 ることはできず、コンパイルエラーとなる。
 -----------------------------------------------------------------
 */
定数の定義: do {
    let name : String = "C. Alcott"
    let age    = 2014 - 1997       // 型を省略。初期値には式が記述できる
    let myName = "E. Mably"; var myAge = 17

    print ("name = \(name), age = \(age), myName = \(myName), myAge = \(myAge)")
}

/**
 -----------------------------------------------------------------
 ■ 型変換
 基本的には、変数や定数には定義した以外の型の値を代入できない。
 Swiftは`「暗黙の型変換」は行わない`。ここで指定しているDouble(), Int()は型変
 換の関数ではなく、Double型, Int型のインスタンスを新しく作るためのイニシャラザ。
 まぁXXXキャストみたいなもんと捉えておく。
 -----------------------------------------------------------------
 */
型定義: do {
    let i: Int = 10
//    var a: Double = i       // Int型はDouble型に変換できずエラー
    print("i = \(i)")

    let r: Double = 0.1
//    var f: Float  = r       // Float型とDouble型でも変換できずエラー
    print("r = \(r)")

    let w: Double = 0.5
    let n: Int    = 10
//    let b = w * n           // 計算式でも型が一致していないとエラーになる
    print("w = \(w), n = \(n)")

    let a: Int    = 10
    var b: Double = Double(a)           // aの値をDouble型に変換して代入
    var c: Int    = Int(b * 1.25)       // 同様に問題なし
    print("a = \(a), b = \(b), c = \(c)")
}

/**
 -----------------------------------------------------------------
 ■ 文字列
 基本的な情報だったのでで省略。なお、"\(式)"のように、バックスラッシュに続いて()
 で囲った式を書くことによって、式の値を表す文字列をその位置に展開することができる。
 これは`文字列埋め込み(string interpolation)`という。
 -----------------------------------------------------------------
 */
文字列: do {
    let n   = 8
    let str = "\(n)の2乗は\(n * n)です。"
    print(str)      // 8の2乗は64です。
}

/**
 -----------------------------------------------------------------
 ■ print関数
 指定した引数の内容は、空白で区切られて1行にできる。また、キーワードにseparator:
 を付けた文字列型の引数を渡すことで、複数の表示内容を区切る文字列を指定できる。
 デフォルトは空白。さらに、キーワードterminator: を付けた文字列型の引数を渡し、
 一連の表示の最後に表示される文字列を指定できる。デフォルトは改行。
 -----------------------------------------------------------------
 */
空白で区切られる: do {
    print(6, 2014, "林檎")        // 6 2014 林檎
}

セパレーター: do {
    print(6, 2014, "林檎", separator: ";")        // 6;2014;林檎
}

/**
 -----------------------------------------------------------------
 ■ 配列
 基本的に一つの配列には同じ型のものしか格納できない。
 -----------------------------------------------------------------
 */

配列: do {
    var a = [2, 5, 8, 11, 7]            // 型省略
    var b: [Int] = [1, 2, 3, 4, 5]      // 型宣言
    print("a配列 = \(a), b配列 = \(b)")

    文字列を格納できる空の配列インスタンスを生成: do {
        var s = [String]()      // イニシャラザ呼び出し
        var t: [String] = []    // これでもOK
        print("s配列の中身 = \(s), t配列の中身 = \(t)")
    }
}

/**
 -----------------------------------------------------------------
 ■ 配列要素へアクセス
 添字は0から始まり、要素外へのアクセスはエラー。要素数の取得は`配列名.count`で取
 得できる。配列も値型なので、コピーすると複製が作成される。そのため、コピー先の値を
 変更しても、コピー元には影響がない。配列の末尾に新しい要素を追加する場合は、
 `appnedメソッド`を使う。なお、`+`や`+=`でも追加できる。
 -----------------------------------------------------------------
 */
配列要素へアクセス: do {
    let digits = ["00", "01", "02", "03"]
    print(digits[2])        // 02
    print(digits.count)     // 要素数取得 4

    コピーしてもコピー元のdigitsには影響がない: do {
        var nums = digits       // numsにdigitsの複製を代入
        nums[2]  = "Two"        // 値を変更
//        digits[2] = "Two"       // 定数の値は変更できないため、エラー
        print(digits[2])        // 02
        print(nums)             // ["00", "01", "Two", "03"]
    }

    要素の追加: do {
        var roman = ["I", "II", "III"]
        roman.append("IV")              // 要素追加
        print(roman)                    // ["I", "II", "III", "IV"]
        let m = roman + ["5", "6"]      // 要素追加
        print(m)                        // ["I", "II", "III", "IV", "5", "6"]
        roman += ["V", "VI"]            // 要素追加
        print(roman)                    // ["I", "II", "III", "IV", "V", "VI"]
    }
}

/**
 -----------------------------------------------------------------
 ■ 演算子
 インクリメント(++)、デクリメント(--)演算子はSwift3で廃止されている。
 `代入の演算子は値を返さない(変数値の更新のみ)`となっているため、値を次々に代入す
 る記述はエラーとなる。演算子の書き方には、Swift独特の取り決めがあるので、注意が
 必要。演算子の両側に空白があるか、あるいはどちらにも空白がない場合には、その演算
 子は二項演算子として解釈される。
 -----------------------------------------------------------------
 */
演算子: do {
    var a = 0
//    a++         // 利用不可のため、エラー
    a += 1      // インクリメント
    print(a)    // 1

    var b = 10
//    a = b = 1   // 次々の代入はできないため、エラー
    print(b)    // 10

    演算子の記述に関する注意: do {
        var c = 10
        var d = 20
        print(c + d)        // 30
        print(c+d)          // 30概念
    }
}
