import UIKit

// 6-2 配列

/**
 -----------------------------------------------------------------
 ■ 配列
 配列のメソッドには、`配列の内容を変更するもの`と`新しい配列を値として返却する`
 ものがある。
 -----------------------------------------------------------------
 */
元の配列の内容を変更する: do {
    var tmp1 = [2, 3, 1, 5, 4]
    print("sort前のtmp1 👉 \(tmp1)")          // [2, 3, 1, 5, 4]
    tmp1.sort()
    print("sort後のtmp1 👉 \(tmp1)")          // [1, 2, 3, 4, 5]
}

元の配列の内容を変更しない: do {
    var tmp1 = [2, 3, 1, 5, 4]
    print("sorted前のtmp1 👉 \(tmp1)")        // [2, 3, 1, 5, 4]
    let tmp2 = tmp1.sorted()
    print("sorted後のtmp1 👉 \(tmp1)")        // [2, 3, 1, 5, 4]
    print("sortedしたtmp2 👉 \(tmp2)")        // [1, 2, 3, 4, 5]
}

配列の部分的な置換: do {
    var a = ["A", "B", "C", "D"]

    // 配列a[0]の要素を新しい値に更新
    a[0...0] = ["あ", "い", "う"]
    print(a)                                // ["あ", "い", "う", "B", "C", "D"]

    // 配列a[1, 2, 3]の要素を新しい値に更新
    a[1...3] = ["1", "2", "3"]              // ["あ", "1", "2", "3", "C", "D"]
    print(a)

    // 配列a[3, 4]を削除
    a[3...4] = []
    print(a)                                // ["あ", "1", "2", "D"]

    // 配列のすべての要素を更新する
    a[...] = ["おわり"]
    print(a)                                // ["おわり"]
}

/**
 -----------------------------------------------------------------
 ■ 部分配列の型
 配列の添字に範囲を指定すると、その部分配列を取得できる。ただし、取得した部分配列の
 型はArray型じゃなくて、ArraySlice型になる。部分配列の添字は、元の配列の添字の
 まま。つまり必ずしも0から添字が使えるわｋではない。
 ただし、元の配列と取得した部分配列はそれぞれ別の配列だから、どちらかの内容を変更
 しても、もう一方に影響はない。
 -----------------------------------------------------------------
 */
部分配列の型: do {
    let a = ["A", "B", "C", "D", "E", "F", "G"]
    print(a[3...5])                         // ["D", "E", "F"]
    print(a[...3])                          // ["A", "B", "C", "D"]
    print(a[5...])                          // ["F", "G"]
    print(a[...])                           // ["A", "B", "C", "D", "E", "F", "G"] ※すべて
}

添字が0から始まらない場合がある: do {
    let one = ["A", "B", "C", "D", "E", "F", "G"]
    let two = one[2..<5]                    // 元の配列の添字のまま、部分配列を作っている
    print("配列bの中身 👉 \(two)")            // ["C", "D", "E"]
    print("添字の始まりは2からだよ 👉 \(two.startIndex)")
    print("だから添字2を指定すると'C'が出力されるよ 👉 \(two[2])")

    // ArraySlice型の配列bをArray型の配列cに新しく生成する
    print("これはArraySlice型の配列だよ 👉 \(two[2])")                                         // C
    let three = [String](two)                                                              // Array<String>のイニシャライザ
    print("Array型の配列に新しく作り直したから、添字は0から数えるようになったよ 👉 \(three[2])")       // E
}

/**
 -----------------------------------------------------------------
 ■ 配列のイニシャライザ
 -----------------------------------------------------------------
 */
配列のイニシャライザ: do {
    let a : Array<Int> = [1, 2, 3, 4, 5]
    let b = Array<String>()
    let c = [Int](0..<10)                                // 0~9までの整数を要素とする
    print("Int型の配列 👉 \(a)")
    print("String型の配列(空だけど) 👉 \(b)")
    print("Int型の配列 👉 \(c)")
}

文字列からCharacter型の配列を取得する: do {
    let chars = [Character]("Swift")
    print("1文字ずつ、要素に格納しているよ 👉 \(chars)")       // ["S", "w", "i", "f", "t"]
}

第一引数の要素を第二引数で指定した回数分繰り返して格納した配列: do {
    let data = [Double](repeating: 0.0, count: 10)
    print("各要素の値'0.0'で、全部で10個あるよ 👉 \(data) / 要素数 : \(data.count)")
    // [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0] / 要素数 : 10
}

型パラメータは型推論で省略すべし: do {
    let lash = Array(repeating: "あ", count: 5)
    print(lash)
    // ["あ", "あ", "あ", "あ", "あ"]
}

/**
 -----------------------------------------------------------------
 ■ 配列のプロパティとメソッド
 -----------------------------------------------------------------
 */
簡単な例 : do {
    var s = [1, 2, 3, 4, 5]
    s.append(contentsOf: stride(from: 10, through: 20, by: 2))      // 元の配列の末尾に[10, 12, 14, 16, 18, 20]を追加
    print(s)                                                        // [1, 2, 3, 4, 5, 10, 12, 14, 16, 18, 20]
    let t = s.prefix(6).reversed()                                  // 先頭から指定した値までの部分配列を取得し、逆順にする
    print("訳わからん複雑な情報が出力される 👉 \(t)")                     // ReversedCollection<ArraySlice<Int>>(_base: ArraySlice([1, 2, 3, 4, 5, 10]))
    print("配列同士の演算を行うと、Array型になる(末尾に0を追加する) 👉 \(t + [0])")     // [10, 5, 4, 3, 2, 1, 0]
}

/**
 -----------------------------------------------------------------
 ■ 配列の比較
 演算子`「==」「!=」`を使うことができる。2つの配列の要素数と先頭から順番に対応す
 る要素がそれぞれ等しければ`true`になる。
 -----------------------------------------------------------------
 */
配列の比較: do {
    let a = [1, 2]
    let b = [2, 1]
    print("aとbは要素が違う部分があるからfalseになるよ 👉 \(a == b)")
    print("aとbは要素が同じになったからtrueになるよ 👉 \(a + [1] == [1] + b)")
    // 一時的にaとbはどれも[1, 2, 1]になってる
}

/**
 -----------------------------------------------------------------
 ■ 可変個の引数が利用できる関数
 可変長引数のこと。可変個の引数を最後に持ってこなくてもOK。引数の一番最初がや途中が
 可変長引数になって大丈夫。また、可変個の引数は、0個でもよい。
 -----------------------------------------------------------------
 */
引数が可変個の関数: do {
    /// 規定値と可変個の引数を受け取り規定値以上の一番大きい値を返却する
    /// - Parameters:
    ///   - first: 規定値
    ///   - params: 可変個の値
    /// - Returns: 一番大きい値
    func maxOfInts(_ first: Int, _ params: Int...) -> Int {
        var m = first
        for param in params {
            if m < param { m = param }
        }
        return m
    }

    // 検証
    print(maxOfInts(3, 9, 2, 6))        // 9
    print(maxOfInts(108, 88))           // 108
    print(maxOfInts(107))               // 107 ※可変個に値を渡さない。
}

可変個の引数列が最後にない関数: do {
    func cards(_ numbers: Int..., label: String) {
        for num in numbers {
            print(label + String(num), terminator: " ")
        }
    }

    // 検証
    cards(3, 5, 7, 9, label: "剣")      // 剣3 剣5 剣7 剣9
    print()
}

/**
 -----------------------------------------------------------------
 ■ 多次元配列
 おなじみ。
 -----------------------------------------------------------------
 */
多次元配列: do {
    var table: [[String]] = [["A", "B"], ["X", "Y", "Z"]]
    print(table[0])                         // ["A", "B"]
    print(table[1][0])                      // X
    table[0].remove(at: 1)                  // 1つ目の配列[A,B]の"B"のみ削除
    print(table)                            // [["A"], ["X", "Y", "Z"]]
}
