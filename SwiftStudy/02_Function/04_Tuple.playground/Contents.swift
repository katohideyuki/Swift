import UIKit

/**
 -----------------------------------------------------------------
 ■ タプル
 異なる型の値をまとめたもの。関連し合う複数個の値をまとめて扱いたいけれど、専用の
 構造体やクラスを定義するほどでもない。時に使う。また、戻り値や値を渡す時などに重
 宝されるらしい。なお、`タプルを元にして複雑なデータ構造は作らないこと`。あくまで、
 一時的に値を保持したりするような用途で使用する。`タプルを型とする変数にタプルを代`
 `入するには、互いの要素の個数と型が同じでなければならない`。タプルの最初の要素に
 アクセスするには、`ドットと添字による「.0」`のような記述を使う。
 -----------------------------------------------------------------
 */
タプルの例: do {
    let m = ("monkey.jpg", 161_022)                     // ファイル名とバイト数
    var m2: (String, Int)  = ("monkey.jpg", 161_022)    // ファイル名とバイト数 ※型定義してもよい
    var img: (String, Int) = m                          // 型と要素数が同じなので代入OK
//    var ng_img: (String, Int, Int) = m2               // コンパイルエラー。要素数が異なるため、代入NG

    print("ファイル名 = \(m.0), バイト数 = \(m.1)")         // ファイル名 = monkey.jpg, バイト数 = 161022
    m2.0 = "tiger.jpg"                                  // 値を更新
    print("ファイル名 = \(m2.0), バイト数 = \(m2.1)")       // ファイル名 = tiger.jpg, バイト数 = 161022
    print(img)                                          // ("monkey.jpg", 161022)
}

/**
 -----------------------------------------------------------------
 ■ タプルと代入操作
 新しい変数を定義し、タプルから値を代入することができる。また、タプルの中の一部の
 値は使わないとき、`「_」というように下線を指定`して、その値を使わないことを明示
 することができる。
 -----------------------------------------------------------------
 */
代入操作の例: do {
    let photo = ("tiger.jpg", 640, 800)     // ファイル名, width, height
    let (file, width, height) = photo       // 新しい定数を定義して、一気に値を格納できる
    print("\(file): \(width)x\(height)")    // tiger.jpg: 640x800
}

一部の値は使わない: do {
    let photo = ("tiger.jpg", 640, 800)     // ファイル名, width, height
    let (file, _, _) = photo                // 新しい定数を定義するが、width, heightは捨てる
    print(file)                             // tiger.jpg
}

二次元タプル: do {
    let pic = ("snake.jpg", (768, 1024))    // タプルの中にタプル
    let (file, (w, h)) = pic                // 新しい定数を定義して、値を格納
    print("\(file): \(w)x\(h)")             // snake.jpg: 768x1024

    let (name, _) = pic                     // さらに新しい定数を定義するが、タプルの中のタプル(w, h)は捨てる
    print (name)                            // snake.jpg
}

/** こんなイメージ → 0 1 1 2 3 5 8 13 21 34 55 89 ...省略 */
タプルを使ってフィボナッチ数列を計算する: do {
    var fibo1 = 0, fibo2 = 1
    print(fibo1, terminator: " ")                   // 最初の出力
    // 値を入れ替える処理を50回繰り返す
    for _ in 0 ..< 50 {
        (fibo1, fibo2) = (fibo2, fibo1 + fibo2)     // 新しい項を計算し、値を入れ替える
        print(fibo1, terminator: " ")
    }
    print()                                         // 改行
}

/**
 -----------------------------------------------------------------
 ■ タプルを返す関数
 関数の返り値がないことを、要素が1つもないタプルの形()で表現する。つまり、関数の返
 り値は常にタプルである。なお、値がないことを示すVoid型を使うこともできるが、Void
 は()の別名として宣言しているにすぎない。
 -----------------------------------------------------------------
 */
BMIを計算する関数: do {
    /// 身長と体重から肥満度を表すBMIを求め、同時に理想的なBMI値に対応する体重を
    /// 計算する。
    /// - Parameters:
    ///   - tall: 身長
    ///   - weight: 体重
    /// - Returns: BMI値と理想的なBMI値に対応する体重
    func BMI(tall: Double, weight: Double) -> (Double, Double) {
        let ideal = 22.0                // 理想的な値とされるBMI値
        let t2 = tall * tall / 10000.0  // cmをmに変換して二乗
        let index = weight / t2         // BMIを計算
        return (index, ideal * t2)      // BMI値と理想的なBMI値を想定した体重
    }

    // 関数を呼び出し、結果が格納されたタプルを取得
    let result = BMI(tall: 177.0, weight: 80.0)
    print("現在のBMI値 = \(result.0) : 理想的なBMI値に対応した体重 = \(result.1)")  // 現在のBMI値 = 25.535446391522232 : 理想的なBMI値に対応した体重 = 68.923
}

/**
 -----------------------------------------------------------------
 ■ キーワード付きのタプル
 タプルにもキーワードをつけることができる。アクセス方法はタプルを添字と同じような
 感じで、`変数名.キーワード名`。また、キーワードはすべての要素につけなければなら
 ないという制約はなく、一部だけもOK。ただし、キーワードの重複はNG。
 -----------------------------------------------------------------
 */
キーワード付きのタプルの例: do {
    let photo = (file: "tiger", width: 640, height: 800)
    print("ファイル名 = \(photo.0)")         // ファイル名 = tiger
    print("ファイル名 = \(photo.file)")      // ファイル名 = tiger

    let image = (file: "crab.svg", 1024, 720)                       // キーワードは一部だけでもOK
//    let movie = (title: "物語", time: 64, time: 69, time: 83)      // コンパイルエラー。キーボードが重複しているため。
}

/**
 -----------------------------------------------------------------
 ■ キーワード付きのタプルと代入
 `キーワードが異なるタプル同士の代入はできない`。ただし、`キャスト`をすればOK。
 型変換の演算子を使っていったんキーワードなしのタプルにキャストしてから代入するとい
 うこと。キャスト演算子は`「式 as 型」`のように記述する。また、同じキーワード同士
 なら、要素の順番が異なっていても代入できる。また、ややこしいが、キーワードがない要
 素は、まだ値の決まらない要素に、並んでいる順番で代入される。といっても、そもそも見
 づらいし`非推奨`という警告が表示されるので、使わないこと。
 警告`「Expression shuffles the elements of this tuple; this behavior`
 `is deprecated」`
 -----------------------------------------------------------------
 */
キャストしてタプル同士を代入する例: do {
    let img = ("phoenix.png", 1200, 800)
    let photo = (file: "tiger.png", width: 640, height: 800)

    var v1: (String, Int, Int) = img                        // 代入先でキーワードを付与してないが、型が同じなのでOK。
    var v2: (file: String, width: Int, height: Int) = img   // 代入先でキーワードを付与しているが、代入元がキーワードを付与していないのでOK。
    var v3: (image: String, x: Int, y: Int) = img           // 代入先でキーワードを付与しているが、代入元がキーワードを付与していないのでOK

    v1 = photo      // 代入先でキーワードを付与してないが、型が同じなのでOK。
    v2 = photo      // 代入先でキーワードを付与しているが、代入元と同じキーワードなのでOK。
//    v3 = photo    // コンパイルエラー。代入先でキーワードを付与しているが、代入元とキーワードが異なるためNG。

    print(v1)       // ("tiger.png", 640, 800)
    print(v2)       // (file: "tiger.png", width: 640, height: 800)
    print(v3)       // (image: "phoenix.png", x: 1200, y: 800)
}

キーワード付きなら要素の順番が異なっても代入できる: do {
    var x = 0, y = 0, z = 0
    (red: x, green: y, blue: z) = (blue: 5, red: 250, green: 220)   // 代入先と代入元で要素順が異なるがOK
    print("x(red) = \(x), y(green) = \(y), z(blue) = \(z)")         // x(red) = 250, y(green) = 220, z(blue) = 5

    var t: (red: Int, green: Int, blue: Int) = (blue: 80, 0, 200)   // 代入先と代入元で要素順が異なる上に、要素元でキーワードを指定していない値があるがOK
    print(t)                                                        // (red: 0, green: 200, blue: 80)
}

/**
 -----------------------------------------------------------------
 ■ キーワード付きのタプルを返す関数
 関数の返り値も、キーワード付きのタプルにできる。呼び出した側で補完機能が使えてい
 れば分かりやすい。
 -----------------------------------------------------------------
 */
キーワード付きのタプルを返す: do {
    /// 身長と体重から肥満度を表すBMIを求め、同時に理想的なBMI値に対応する体重を
    /// 計算する。
    /// - Parameters:
    ///   - tall: 身長
    ///   - weight: 体重
    /// - Returns: BMI値と理想的なBMI値に対応する体重を格納したタプル
    func BMI(tall: Double, weight: Double) -> (index: Double, ideal: Double) {
        let ideal = 22.0                // 理想的な値とされるBMI値
        let t2 = tall * tall / 10000.0  // cmをmに変換して二乗
        let index = weight / t2         // BMIを計算
        return (index, ideal * t2)      // BMI値と理想的なBMI値を想定した体重
    }

    let w = BMI(tall: 168.0, weight: 73.5)
    print("BMI=\(w.index), target=\(w.ideal)")      // BMI=26.041666666666668, target=62.0928
}

/**
 -----------------------------------------------------------------
 ■ タプルの比較
 タプルは要素の個数やそれぞれの型が異なるため、一般に相互を比較することは困難。た
 だし、制約付きでタプル同士を比較することができる。
 1. 同じ要素数でそれぞれ同じ型
 2. 要素数は最大6個
 3. 要素としてタプルを含めていない
 代償比較の場合、辞書式順で行われる先頭要素を比較し、等しければ2番目の要素を比較す
 るという手順で進み、最初に違いが見つかった時点の結果が全体の結果になる。なお、要
 素は互いに代償比較が可能な型でなければならない。キーワード付きのタプルでも比較可
 能だが、`キーボードは一切無視して比較が行われる`。代入はキーワードに対応して行わ
 れるがので、代入前後でタプルが等しくなくなったり、エラーを起こす可能性があるので
 注意が必要。
 -----------------------------------------------------------------
 */
タプルの比較: do {
    let a = (7, 29, "bee") == (7, 31 - 2, "be" + "e")
//    let b = (5, 14, "snail") != (5, 14, 0, "be")          // コンパイルエラー。要素数が異なるため。
//    let c = ((10, 31), "medusa") == ((10, 31), "miia")    // コンパイルエラー。タプルの中にタプルが含まれるため。
    print(a)        // true

    let d = (31, 10, "miia")  > (31, 1, "suu")
    let e = (1, 18, 0, 10000) > (1, 18, 2, 99)
//    let f = ("snail", true)   > ("medusa", false)         // コンパイルエラー。Bool型は大小比較できないため。
    print(d)        // true
    print(e)        // false

    let s: (month: Int, day: Int, name: String) = (4, 24, "卯月")
    let t: (day: Int, month: Int, String) = s               // キーワードに対応して要素が代入される。
    print(s == t)   // false: (4, 24, "卯月")と(24, 4, "卯月")でキーワードは無視されており、純粋な要素の並び順で比較が行われるが、比較同士の型がたまたま同じなのでエラーにならず比較できている。

    let k = (name: "皐月", month: 5)
    var u = (month: 4, name: "卯月")
    u = k           //　キーワードに対応して要素が代入される。
//    print(k == u) // コンパイルエラー。("皐月", 5)と(4, "卯月")でキーワードは無視されており、純粋な要素の並び順で比較が行われ、比較同士の型が異なる結果になるため。
}
